-- Bloxburg Auto Build Script with Rayfield Interface
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")
local PathfindingService = game:GetService("PathfindingService")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

-- Initialize Rayfield Interface (assuming Rayfield is already loaded)
local Rayfield = Rayfield or getgenv().Rayfield
local AutoBuildSection = Rayfield:CreateSection("Auto Build")
local MiscSection = Rayfield:CreateSection("Miscellaneous")

-- Auto Build Dropdowns
copyHouseDropdown = AutoBuildSection:AddDropdown({
    Name = "Copy House",
    Options = {"Loading..."},
    CurrentOption = "",
    Flag = "copyHouse",
    Callback = function(Value)
        local targetPlayer = Players:FindFirstChild(Value)
        if targetPlayer then
            copyPlayerHousePrompt(targetPlayer)
        end
    end
})

loadHouseDropdown = AutoBuildSection:AddDropdown({
    Name = "Load House",
    Options = {"Loading..."},
    CurrentOption = "",
    Flag = "loadHouse",
    Callback = function(Value)
        loadPlayerHousePrompt(Value)
    end
})

-- Misc Dropdowns
teleportToPlotDropdown = MiscSection:AddDropdown({
    Name = "Teleport To Player Plot",
    Options = {"Loading..."},
    CurrentOption = "",
    Flag = "teleportToPlot",
    Callback = function(Value)
        local targetPlayer = Players:FindFirstChild(Value)
        if targetPlayer then
            teleportToPlayerPlot(targetPlayer)
        end
    end
})

do -- // Functions
    local framework = require(ReplicatedStorage:WaitForChild('Framework'))
    framework = getupvalue(framework, 3)

    local modules
    local network
    local jobManager
    local guiHandler

    repeat
        task.wait()
        modules = framework.Modules
        if (not modules) then continue end
        network = framework.net
        if (not network) then continue end
        jobManager = modules.JobHandler
        if (not jobManager) then continue end
        guiHandler = modules.GUIHandler
        if (not guiHandler) then continue end
    until modules and network and jobManager and guiHandler

    local saveHouse
    local loadHouse

    if (not isfolder('Aztup Hub V3/Bloxburg Houses')) then
        makefolder('Aztup Hub V3/Bloxburg Houses')
    end

    hookfunction(getfenv(network.FireServer).i, function()
        print('Ban attempt lel')
    end)

    guiHandler:AlertBox(
        'If you encounter any bugs using the auto farm make sure you post them in the discord #bug-reports channel.\nIn all cases to not get banned make sure that you buy a car after you finished your shift and make sure that you dont farm overnight.\n\nWe are not responsible in any shape or form if you get banned!',
        'Warning',
        0.5
    )

    function saveHouse(player)
        local plot = workspace.Plots[string.format("Plot_%s", player.Name)]
        local ground = plot.Ground

        local saveData = {}
        saveData.Walls = {}
        saveData.Paths = {}
        saveData.Floors = {}
        saveData.Roofs = {}
        saveData.Pools = {}
        saveData.Fences = {}
        saveData.Ground = {}
        saveData.Ground.Counters = {}
        saveData.Ground.Objects = {}
        saveData.Basements = {}

        local objects = {}
        local counters = {}

        local function getRotation(object)
            return tostring(plot.PrimaryPart.CFrame:ToObjectSpace(object))
        end

        local function getFloor(position)
            local currentFloor, currentFloorDistance = nil, math.huge
            for i, v in next, plot.House.Floor:GetChildren() do
                if((v.Part.Position - position).Magnitude <= currentFloorDistance) then
                    currentFloor = v
                    currentFloorDistance = (v.Part.Position - position).Magnitude
                end
            end
            return currentFloor
        end

        local function getPolePosition(pole)
            pole = pole.Value
            if(pole.Parent:IsA('BasePart')) then
                return pole.Parent.Position
            else
                return pole.Parent.Value
            end
            return error('something went wrong!')
        end

        for _, object in next, plot.House.Objects:GetChildren() do
            local floor = getFloor(object.Position) or plot
            local objectData = {}
            objectData.Name = object.Name
            objectData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(object)
            objectData.Rot = getRotation(object.CFrame)
            objectData.Position = tostring(ground.CFrame:PointToObjectSpace(object.Position))

            if(not objects[floor]) then
                objects[floor] = {}
            end

            if(object:FindFirstChild('ItemHolder')) then
                for _, item in next, object.ItemHolder:GetChildren() do
                    if(item:FindFirstChild('RailingSegment')) then
                        if(not objectData.Fences) then
                            objectData.Fences = {}
                        end
                        local _, from = framework.Shared.FenceService:GetEdgePositions(item)
                        local offSetFrom = ground.CFrame:PointToObjectSpace(from)
                        local itemData = {}
                        itemData.Name = item.Name
                        itemData.From = tostring(offSetFrom)
                        itemData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item)
                        itemData.Segment = item.RailingSegment.Value.Name
                        table.insert(objectData.Fences, itemData)
                    else
                        if(not objectData.Items) then
                            objectData.Items = {}
                        end
                        local itemData = {}
                        itemData.Name = item.Name
                        itemData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item)
                        itemData.Rot = getRotation(item.CFrame)
                        itemData.Position = tostring(ground.CFrame:PointToObjectSpace(item.Position))
                        table.insert(objectData.Items, itemData)
                    end
                end
            end

            table.insert(objects[floor], objectData)
        end

        for _, counter in next, plot.House.Counters:GetChildren() do
            local floor = getFloor(counter.Position) or plot
            local counterData = {}
            counterData.Name = counter.Name
            counterData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(counter)
            counterData.Rot = getRotation(counter.CFrame)
            counterData.Position = tostring(ground.CFrame:PointToObjectSpace(counter.Position))

            if(not counters[floor]) then
                counters[floor] = {}
            end

            if(counter:FindFirstChild('ItemHolder')) then
                for _, item in next, counter.ItemHolder:GetChildren() do
                    if(not counterData.Items) then
                        counterData.Items = {}
                    end
                    local itemData = {}
                    itemData.Name = item.Name
                    itemData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item)
                    itemData.Rot = getRotation(item.CFrame)
                    itemData.Position = tostring(ground.CFrame:PointToObjectSpace(item.Position))
                    table.insert(counterData.Items, itemData)
                end
            end

            table.insert(counters[floor], counterData)
        end

        for _, wall in next, plot.House.Walls:GetChildren() do
            if(wall.Name ~= 'Poles') then
                local offSetFrom, offSetTo = ground.CFrame:PointToObjectSpace(getPolePosition(wall.BPole)), ground.CFrame:PointToObjectSpace(getPolePosition(wall.FPole))
                local wallData = {}
                wallData.From = tostring(offSetFrom)
                wallData.To = tostring(offSetTo)
                wallData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(wall)
                wallData.Items = {}

                if(wall:FindFirstChild('ItemHolder')) then
                    for _, item in next, wall.ItemHolder:GetChildren() do
                        local itemData = {}
                        itemData.Name = item.Name
                        itemData.Position = tostring(ground.CFrame:PointToObjectSpace(item.Position))
                        itemData.Side = item:FindFirstChild("SideValue") and item.SideValue.Value == -1 or nil
                        itemData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item)
                        local itemConfig = framework.Items:GetItem(item.Name)
                        if(itemConfig.Type ~= 'Windows' and itemConfig.Type ~= 'Doors') then
                            itemData.Rot = getRotation(item.CFrame)
                        end
                        if(item:FindFirstChild('ItemHolder')) then
                            itemData.Items = {}
                            for _, item2 in next, item.ItemHolder:GetChildren() do
                                local itemData2 = {}
                                itemData2.Name = item2.Name
                                itemData2.Rot = getRotation(item2.CFrame)
                                itemData2.Position = tostring(ground.CFrame:PointToObjectSpace(item2.Position))
                                itemData2.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item2)
                                table.insert(itemData.Items, itemData2)
                            end
                        end
                        table.insert(wallData.Items, itemData)
                    end
                end
                table.insert(saveData.Walls, wallData)
            end
        end

        for _, floor in next, plot.House.Floor:GetChildren() do
            local floorData = {}
            floorData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(floor)
            floorData.Points = {}
            floorData.Objects = objects[floor] or {}
            floorData.Counters = counters[floor] or {}

            for i, v in next, floor.PointData:GetChildren() do
                table.insert(floorData.Points, tostring(v.Value))
            end
            table.insert(saveData.Floors, floorData)
        end

        for _, roof in next, plot.House.Roof:GetChildren() do
            local roofData = {}
            roofData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(roof)
            roofData.Name = roof.Name
            roofData.Points = {}
            roofData.Items = {}

            for i, v in next, roof.PointData:GetChildren() do
                table.insert(roofData.Points, tostring(v.Value))
            end

            if(roof:FindFirstChild('ItemHolder')) then
                for _, item in next, roof.ItemHolder:GetChildren() do
                    local itemData = {}
                    itemData.Name = item.Name
                    itemData.Position = tostring(ground.CFrame:PointToObjectSpace(item.Position))
                    itemData.Rot = getRotation(item.CFrame)
                    itemData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item)
                    table.insert(roofData.Items, itemData)
                end
            end
            table.insert(saveData.Roofs, roofData)
        end

        for _, path in next, plot.House.Paths:GetChildren() do
            if(path.Name ~= 'Poles') then
                local offSetFrom, offSetTo = ground.CFrame:PointToObjectSpace(getPolePosition(path.BPole)), ground.CFrame:PointToObjectSpace(getPolePosition(path.FPole))
                local floorData = {}
                floorData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(path)
                floorData.From = tostring(offSetFrom)
                floorData.To = tostring(offSetTo)
                table.insert(saveData.Paths, floorData)
            end
        end

        for _, pool in next, plot.House.Pools:GetChildren() do
            local poolData = {}
            poolData.Position = tostring(ground.CFrame:ToObjectSpace(pool.HitBox.CFrame))
            poolData.Size = tostring(Vector2.new(pool.HitBox.Size.X, pool.HitBox.Size.Z))
            poolData.Type = pool.Name
            table.insert(saveData.Pools, poolData)
        end

        for _, basement in next, plot.House.Basements:GetChildren() do
            local basementData = {}
            basementData.Position = tostring(ground.CFrame:ToObjectSpace(basement.HitBox.CFrame))
            basementData.Size = tostring(Vector2.new(basement.HitBox.Size.X, basement.HitBox.Size.Z))
            basementData.Type = basement.Name
            table.insert(saveData.Basements, basementData)
        end

        for _, fence in next, plot.House.Fences:GetChildren() do
            if(fence.Name ~= 'Poles') then
                local to, from = framework.Shared.FenceService:GetEdgePositions(fence)
                local offSetTo, offSetFrom = ground.CFrame:PointToObjectSpace(to), ground.CFrame:PointToObjectSpace(from)
                local fenceData = {}
                fenceData.To = tostring(offSetTo)
                fenceData.From = tostring(offSetFrom)
                fenceData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(fence)
                fenceData.Name = fence.Name
                fenceData.Items = {}

                if(fence:FindFirstChild('ItemHolder')) then
                    for _, item in next, fence.ItemHolder:GetChildren() do
                        local itemData = {}
                        itemData.AppearanceData = framework.Shared.ObjectService:GetAppearanceData(item)
                        itemData.Name = item.Name
                        itemData.Rot = getRotation(item.CFrame)
                        itemData.Position = tostring(ground.CFrame:PointToObjectSpace(item.Position))
                        table.insert(fenceData.Items, itemData)
                    end
                end
                table.insert(saveData.Fences, fenceData)
            end
        end

        if(objects[plot]) then
            saveData.Ground.Objects = objects[plot]
        end
        if(counters[plot]) then
            saveData.Ground.Counters = counters[plot]
        end

        local playerHouses = ReplicatedStorage.Stats[player.Name].Houses
        local playerHouse
        for _, v in next, ReplicatedStorage.Stats[player.Name].Houses:GetChildren() do
            if(v.Value == playerHouses.Value) then
                playerHouse = v
            end
        end

        saveData.totalValue = playerHouse.TotalValue.Value or 'Unknown'
        saveData.bsValue = playerHouse.BSValue.Value or 'Unknown'
        writefile(string.format('Aztup Hub V3/Bloxburg Houses/%s.json', player.Name), HttpService:JSONEncode(saveData))
    end

    function loadHouse(houseData)
        local myPlot = workspace.Plots['Plot_' .. Players.LocalPlayer.Name]
        local myGround = myPlot.Ground
        local placements = 0
        local oldFramework = framework

        local streamRefTypes = {
            'PlaceObject',
            'PlaceWall',
            'PlaceFloor',
            'PlacePath',
            'PlaceRoof'
        }

        local framework = {
            net = setmetatable({
                InvokeServer = function(self, data)
                    placements = placements + 1
                    if(placements >= 4) then
                        placements = 0
                        task.wait(3)
                    end
                    local dataType = data.Type
                    local returnData = {oldFramework.net:InvokeServer(data)}
                    if (table.find(streamRefTypes, dataType)) then
                        returnData[1] = typeof(returnData[1]) == 'Instance' and returnData[1].Value
                    end
                    return unpack(returnData)
                end
            }, {__index = oldFramework.net})
        }

        local position = framework.net:InvokeServer({
            Type = 'ToPlot',
            Player = LocalPlayer
        })
        LocalPlayer.Character:SetPrimaryPartCFrame(position)

        framework.net:InvokeServer({
            Type = 'EnterBuild',
            Plot = myPlot
        })

        local function convertToVector3(vectorString)
            return myGround.CFrame:PointToWorldSpace(Vector3.new(unpack(vectorString:split(','))))
        end

        local function convertPoints(points)
            local newPoints = {}
            for i, v in next, points do
                table.insert(newPoints, convertToVector3(v))
            end
            return newPoints
        end

        local function convertRot(cf)
            if(not cf) then
                return
            end
            local newCf = myGround.CFrame:ToWorldSpace(CFrame.new(unpack(cf:split(','))))
            local rot = -math.atan2(newCf.lookVector.z, newCf.lookVector.x) - math.pi * 0.5
            if(rot < 0) then
                rot = 2 * math.pi + rot
            end
            return rot
        end

        local count = 0
        local totalCount = 0
        for i, v in next, houseData do
            if(typeof(v) == 'table') then
                totalCount = totalCount + #v
            end
        end

        print('starting for', count)

        for _, wallData in next, houseData.Walls do
            local offSetFrom, offSetTo = convertToVector3(wallData.From), convertToVector3(wallData.To)
            local wall = framework.net:InvokeServer({
                Type = 'PlaceWall',
                From = offSetFrom,
                To = offSetTo
            })

            for _, itemData in next, wallData.Items do
                local item = framework.net:InvokeServer({
                    Type = 'PlaceObject',
                    Name = itemData.Name,
                    TargetModel = wall,
                    Rot = convertRot(itemData.Rot),
                    Pos = convertToVector3(itemData.Position),
                })

                if(itemData.Items) then
                    for _, itemData2 in next, itemData.Items do
                        local item2 = framework.net:InvokeServer({
                            Type = 'PlaceObject',
                            Name = itemData2.Name,
                            TargetModel = item,
                            Rot = convertRot(itemData2.Rot),
                            Pos = convertToVector3(itemData2.Position),
                        })
                        framework.net:InvokeServer({
                            Type = 'ColorObject',
                            Object = item2,
                            UseMaterials = true,
                            Data = itemData2.AppearanceData
                        })
                    end
                end
                framework.net:InvokeServer({
                    Type = 'ColorObject',
                    Object = item,
                    UseMaterials = true,
                    Data = itemData.AppearanceData
                })
            end

            framework.net:InvokeServer({
                Type = 'ColorObject',
                Object = wall,
                UseMaterials = true,
                Data = {wallData.AppearanceData[1], {}, {}, {}},
                Side = 'R'
            })
            framework.net:InvokeServer({
                Type = 'ColorObject',
                Object = wall,
                UseMaterials = true,
                Data = {wallData.AppearanceData[2], {}, {}, {}},
                Side = 'L'
            })
        end

        for _, floorData in next, houseData.Floors do
            local floor = framework.net:InvokeServer({
                Type = 'PlaceFloor',
                Points = convertPoints(floorData.Points)
            })

            for _, itemData in next, floorData.Objects or {} do
                local item = framework.net:InvokeServer({
                    Type = 'PlaceObject',
                    Name = itemData.Name,
                    TargetModel = floor,
                    Rot = convertRot(itemData.Rot),
                    Pos = convertToVector3(itemData.Position),
                })
                framework.net:InvokeServer({
                    Type = 'ColorObject',
                    Object = item,
                    UseMaterials = true,
                    Data = itemData.AppearanceData
                })

                if(itemData.Fences and item) then
                    for _, fenceData in next, itemData.Fences do
                        local fence = framework.net:InvokeServer({
                            Type = 'PlaceObject',
                            Name = fenceData.Name,
                            Pos = convertToVector3(fenceData.From),
                            RailingSegment = item.ObjectModel.Railings[fenceData.Segment]
                        })
                        if(not fence and debugMode) then
                            warn(fence)
                            error('failed to place fence')
                        end
                        framework.net:InvokeServer({
                            Type = 'ColorObject',
                            Object = fence,
                            UseMaterials = true,
                            Data = fenceData.AppearanceData
                        })
                    end
                end

                if(itemData.Items) then
                    for _, itemData2 in next, itemData.Items do
                        local item2 = framework.net:InvokeServer({
                            Type = 'PlaceObject',
                            Name = itemData2.Name,
                            TargetModel = item,
                            Rot = convertRot(itemData2.Rot),
                            Pos = convertToVector3(itemData2.Position),
                        })
                        framework.net:InvokeServer({
                            Type = 'ColorObject',
                            Object = item2,
                            UseMaterials = true,
                            Data = itemData2.AppearanceData
                        })
                    end
                end
            end

            for _, counterData in next, floorData.Counters or {} do
                local item = framework.net:InvokeServer({
                    Type = 'PlaceObject',
                    Name = counterData.Name,
                    TargetModel = floor,
                    Rot = convertRot(counterData.Rot),
                    Pos = convertToVector3(counterData.Position),
                })

                if(counterData.Items) then
                    for _, itemData in next, counterData.Items do
                        local item2 = framework.net:InvokeServer({
                            Type = 'PlaceObject',
                            Name = itemData.Name,
                            TargetModel = item,
                            Rot = convertRot(itemData.Rot),
                            Pos = convertToVector3(itemData.Position),
                        })
                        framework.net:InvokeServer({
                            Type = 'ColorObject',
                            Object = item2,
                            UseMaterials = true,
                            Data = itemData.AppearanceData
                        })
                    end
                end

                framework.net:InvokeServer({
                    Type = 'ColorObject',
                    Object = item,
                    UseMaterials = true,
                    Data = counterData.AppearanceData
                })
            end

            framework.net:InvokeServer({
                Type = 'ColorObject',
                Object = floor,
                UseMaterials = true,
                Data = floorData.AppearanceData
            })
        end

        for _, pathData in next, houseData.Paths do
            local path = framework.net:InvokeServer({
                Type = 'PlacePath',
                To = convertToVector3(pathData.To),
                From = convertToVector3(pathData.From)
            })
            framework.net:InvokeServer({
                Type = 'ColorObject',
                Object = path,
                UseMaterials = true,
                Data = pathData.AppearanceData
            })
        end

        for _, roofData in next, houseData.Roofs do
            local roof = framework.net:InvokeServer({
                Type = 'PlaceRoof',
                Points = convertPoints(roofData.Points),
                Start = convertToVector3(roofData.Points[1]),
                Settings = {
                    IsPreview = true,
                    Type = roofData.Name,
                    RotateNum = 0
                }
            })

            for _, itemData in next, roofData.Items or {} do
                local item = framework.net:InvokeServer({
                    Type = 'PlaceObject',
                    Name = itemData.Name,
                    TargetModel = roof,
                    Rot = convertRot(itemData.Rot),
                    Pos = convertToVector3(itemData.Position),
                })
                framework.net:InvokeServer({
                    Type = 'ColorObject',
                    Object = item,
                    UseMaterials = true,
                    Data = itemData.AppearanceData
                })
            end

            framework.net:InvokeServer({
                Type = 'ColorObject',
                Object = roof,
                UseMaterials = true,
                Data = roofData.AppearanceData
            })
        end

        for _, poolData in next, houseData.Pools do
            framework.net:InvokeServer({
                Type = 'PlacePool',
                Size = Vector2.new(unpack(poolData.Size:split(','))),
                Center = CFrame.new(unpack(poolData.Position:split(','))),
                ItemType = poolData.Type
            })
            count = count + 1
        end

        for _, basementData in next, houseData.Basements do
            framework.net:InvokeServer({
                Type = 'PlaceBasement',
                ItemType = 'Basements',
                Size = Vector2.new(unpack(basementData.Size:split(','))),
                Center = CFrame.new(unpack(basementData.Position:split(','))) - Vector3.new(0, -12.49, 0)
            })
        end

        for _, fenceData in next, houseData.Fences do
            local fence = framework.net:InvokeServer({
                Type = 'PlaceObject',
                Name = fenceData.Name,
                StartPos = convertToVector3(fenceData.From),
                Pos = convertToVector3(fenceData.To),
                ItemType = fenceData.Name
            })

            for _, itemData in next, fenceData.Items do
                local item = framework.net:InvokeServer({
                    Type = 'PlaceObject',
                    Name = itemData.Name,
                    TargetModel = fence,
                    Rot = convertRot(itemData.Rot),
                    Pos = convertToVector3(itemData.Position),
                })
                framework.net:InvokeServer({
                    Type = 'ColorObject',
                    Object = item,
                    UseMaterials = true,
                    Data = itemData.AppearanceData
                })
            end

            framework.net:InvokeServer({
                Type = 'ColorObject',
                Object = fence,
                UseMaterials = true,
                Data = fenceData.AppearanceData
            })
        end

        for _, groundItem in next, houseData.Ground.Objects do
            local item = framework.net:InvokeServer({
                Type = 'PlaceObject',
                Name = groundItem.Name,
                TargetModel = myPlot.GroundParts.Ground,
                Rot = convertRot(groundItem.Rot),
                Pos = convertToVector3(groundItem.Position),
            })

            if(groundItem.Fences and item) then
                for _, fenceData in next, groundItem.Fences do
                    local fence = framework.net:InvokeServer({
                        Type = 'PlaceObject',
                        Name = fenceData.Name,
                        Pos = convertToVector3(fenceData.From),
                        RailingSegment = item.ObjectModel.Railings[fenceData.Segment]
                    })
                    framework.net:InvokeServer({
                        Type = 'ColorObject',
                        Object = fence,
                        UseMaterials = true,
                        Data = fenceData.AppearanceData
                    })
                end
            end

            if(groundItem.Items) then
                for _, itemData2 in next, groundItem.Items do
                    local item2 = framework.net:InvokeServer({
                        Type = 'PlaceObject',
                        Name = itemData2.Name,
                        TargetModel = item,
                        Rot = convertRot(itemData2.Rot),
                        Pos = convertToVector3(itemData2.Position),
                    })
                    framework.net:InvokeServer({
                        Type = 'ColorObject',
                        Object = item2,
                        UseMaterials = true,
                        Data = itemData2.AppearanceData
                    })
                end
            end

            framework.net:InvokeServer({
                Type = 'ColorObject',
                Object = item,
                UseMaterials = true,
                Data = groundItem.AppearanceData
            })
        end

        for _, counterItem in next, houseData.Ground.Counters do
            local item = framework.net:InvokeServer({
                Type = 'PlaceObject',
                Name = counterItem.Name,
                Pos = convertToVector3(counterItem.Position),
                Rot = convertRot(counterItem.Rot),
                TargetModel = myPlot.GroundParts.Ground,
            })

            if(counterItem.Items) then
                for _, itemData in next, counterItem.Items do
                    local item2 = framework.net:InvokeServer({
                        Type = 'PlaceObject',
                        Name = itemData.Name,
                        TargetModel = item,
                        Rot = convertRot(itemData.Rot),
                        Pos = convertToVector3(itemData.Position),
                    })
                    framework.net:InvokeServer({
                        Type = 'ColorObject',
                        Object = item2,
                        UseMaterials = true,
                        Data = itemData.AppearanceData
                    })
                end
            end

            framework.net:InvokeServer({
                Type = 'ColorObject',
                Object = item,
                UseMaterials = true,
                Data = counterItem.AppearanceData
            })
        end

        framework.net:FireServer({
            Type = 'ExitBuild'
        })
    end

    do -- // Remote Spy
        local oldFireServer = network.FireServer
        local blacklistedTypes = {'LookDir', 'GetServerTime', 'CheckOwnsAsset', 'VehicleUpdate'}

        oldFireServer = hookfunction(network.FireServer, function(self, data, ...)
            if (data.Type == 'EndShift' and Rayfield.flags.pizzaDelivery) then return end

            if (not table.find(blacklistedTypes, data.Type)) then
                print(prettyPrint({
                    data = data,
                    traceback = debug.traceback()
                }))
            end

            return pcall(oldFireServer, self, data, ...)
        end)

        local oldInvokeServer = network.InvokeServer
        oldInvokeServer = hookfunction(network.InvokeServer, function(self, data, ...)
            local fireType = data.Type
            local returnData = {select(2, pcall(oldInvokeServer, self, data, ...))}

            if (not table.find(blacklistedTypes, fireType)) then
                print(prettyPrint({
                    returnData = returnData,
                    data = data,
                    type = fireType,
                    traceback = debug.traceback()
                }))
            end

            return unpack(returnData)
        end)
    end

    local function findCurrentWorkstation(workStations, justFindIt)
        local closestDistance, currentWorkstation = math.huge, nil
        local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart

        if(not rootPart) then
            return
        end

        for i, v in next, workStations:GetChildren() do
            local distance = (rootPart.Position - v.PrimaryPart.Position).Magnitude

            if(distance <= closestDistance and (v.InUse.Value == nil or v.InUse.Value == LocalPlayer)) then
                closestDistance, currentWorkstation = distance, v
            end
        end

        return currentWorkstation
    end

    local function findCurrentWorkstationBens(workStations)
        for i,v in next, workStations:GetChildren() do
            local customer = v.Occupied.Value
            if(customer and customer.Order.Value == '') then
                return v
            end
        end
    end

    local function tweenTeleport(position)
        local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart
        if(not rootPart) then
            return warn('no root part for tween tp :/')
        end

        local path = PathfindingService:CreatePath()
        path:ComputeAsync(rootPart.Position, position)

        local waypoints = path:GetWaypoints()
        local cfValue = Instance.new('CFrameValue')
        local connection

        cfValue.Value = rootPart.CFrame

        connection = cfValue:GetPropertyChangedSignal('Value'):Connect(function()
            LocalPlayer.Character:SetPrimaryPartCFrame(cfValue.Value)
        end)

        for i, v in next, waypoints do
            local tweenInfo = TweenInfo.new((rootPart.Position - v.Position).Magnitude / 20, Enum.EasingStyle.Linear)
            local tween = TweenService:Create(cfValue, tweenInfo, {Value = CFrame.new(v.Position + Vector3.new(0, 4, 0))})

            tween:Play()
            tween.Completed:Wait()
        end

        connection:Disconnect()
        connection = nil

        cfValue:Destroy()
        cfValue = nil

        path.Blocked:Connect(function()
            warn('BLOCKED IN PATH!')
        end)
    end

    local function getOrder()
        local box = workspace.Environment.Locations.PizzaPlanet.Conveyor.MovingBoxes:WaitForChild('Box_1')
        local rootPart = LocalPlayer.Character and LocalPlayer.Character.PrimaryPart
        if(not rootPart) then
            return print('No root part :/')
        end

        if((box.Position - rootPart.Position).Magnitude <= 8) then
            local order = framework.net:InvokeServer({
                Type = "TakePizzaBox",
                Box = box
            })

            if(order) then
                return order
            else
                return getOrder()
            end
        else
            print('tween teleport')
            tweenTeleport(Vector3.new(1171.3407, 13.6576843, 273.778717))
            return getOrder()
        end
    end

    function copyPlayerHousePrompt(targetPlayer)
        task.wait()
        if(not guiHandler:ConfirmBox(string.format('\nThis will copy the house of %s into your executor workspace folder with the name Bloxburg_House.json.\nIf you want to copy this house simply press Yes (Make sure you can see the house you want to copy or use the teleport to player plot otherwise save house won\'t work properly)\n', targetPlayer.Name, targetPlayer.Name), 'House Copier')) then
            return
        end

        saveHouse(targetPlayer)
        return guiHandler:MessageBox(string.format('House of %s has been copied', targetPlayer.Name), 'Success')
    end

    function loadPlayerHousePrompt(house)
        task.wait()
        local success, houseData = pcall(readfile, string.format('Aztup Hub V3/Bloxburg Houses/%s', house))
        if(not success) then
            return guiHandler:AlertBox('There was an error.','Error')
        end

        houseData = HttpService:JSONDecode(houseData)
        local bsValue = houseData.bsValue
        local totalValue = houseData.totalValue - (bsValue * 20)

        if(not guiHandler:ConfirmBox(string.format('\nAre you sure? You are about to load an house.\nMoney Required: %s\nBloxBux Required: %s\nIf you clicked on this button by mistake simply press No.\n', totalValue, bsValue), 'House Loader', 5)) then
            return
        end

        loadHouse(houseData)
    end

    function teleportToPlayerPlot(targetPlayer)
        local position = framework.net:InvokeServer({
            Type = 'ToPlot',
            Player = targetPlayer
        })
        LocalPlayer.Character:SetPrimaryPartCFrame(position)
    end

    local oldNamecall

    oldNamecall = hookmetamethod(game, '__namecall', function(...)
        SX_VM_CNONE()
        local args = {...}
        local self = args[1]

        if(typeof(self) ~= 'Instance') then return oldNamecall(...) end

        if (checkcaller() and getnamecallmethod() == 'FireServer' and args[2].Order and args[2].Workstation) then
            if (args[2].Workstation.Parent.Name == 'HairdresserWorkstations' and Rayfield.flags.stylezHairDresser) then
                args[2].Order = {
                    args[2].Workstation.Occupied.Value.Order.Style.Value,
                    args[2].Workstation.Occupied.Value.Order.Color.Value
                }
            elseif (args[2].Workstation.Parent.Name == 'BakerWorkstations' and Rayfield.flags.pizzaBaker) then
                args[2].Order = {
                    true,
                    true,
                    true,
                    args[2].Workstation.Order.Value
                }
            end
        end

        return oldNamecall(unpack(args))
    end)
end

-- Populate dropdowns dynamically
local function updateDropdowns()
    local playerList = {}
    for _, player in ipairs(Players:GetPlayers()) do
        table.insert(playerList, player.Name)
    end
    copyHouseDropdown:SetOptions(playerList)
    teleportToPlotDropdown:SetOptions(playerList)

    local houseList = {}
    if isfolder('Aztup Hub V3/Bloxburg Houses') then
        for _, file in ipairs(listfiles('Aztup Hub V3/Bloxburg Houses')) do
            table.insert(houseList, file:match("([^/\\]+)%.json$"))
        end
    end
    loadHouseDropdown:SetOptions(houseList)
end

-- Update dropdowns when players join/leave or houses are saved
Players.PlayerAdded:Connect(updateDropdowns)
Players.PlayerRemoving:Connect(updateDropdowns)
updateDropdowns()
